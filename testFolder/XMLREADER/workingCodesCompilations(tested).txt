########################################################################################################
###################################THIS IS A WORKING CODE ##############################################
########################################################################################################

main.cpp

#include <iostream>
#include "XMLREADER/XMLReader.h"
#include "Device.h"
#include "Job.h"
#include <vector>
using namespace std;

int main() {
    // Load and parse XML file
    XMLReader xmlReader;
    if (!xmlReader.readerXML()) {
        cerr << "Failed to load XML file." << endl;
        return 1;
    }
    // Process parsed data after populating the vectors
    // Print the contents of deviceInfoList
    cout << "Device List:" << endl;
    for (const auto& deviceInfo : xmlReader.getDeviceInfoList()) {
        cout << "Device Name: " << deviceInfo.deviceName << endl;
        cout << "Emissions: " << deviceInfo.emissions << endl;
        cout << "Speed: " << deviceInfo.speed << endl;
        cout << endl;
    }
    // Print the contents of jobInfoList
    cout << "Job List:" << endl;
    for (const auto& jobInfo : xmlReader.getJobInfoList()) {
        cout << "Job Number: " << jobInfo.jobNumber << endl;
        cout << "Page Count: " << jobInfo.pageCount << endl;
        cout << "User Name: " << jobInfo.userName << endl;
        cout << endl;
    }
    return 0;
}

########################################################################################################
###################################THIS IS A WORKING CODE ##############################################
########################################################################################################

main.cpp

#include <iostream>
#include "XMLREADER/XMLReader.h"
#include "Device.h"
#include "Job.h"

using namespace std;

int main() {
    // Load and parse XML file
    XMLReader xmlReader;
    if (!xmlReader.readerXML()) {
        cerr << "Failed to load XML file." << endl;
        return 1;
    }
    // Process the parsed data after populating the vectors
    Device::populateFromXMLReader(xmlReader);
    cout << "Device List:" << endl;
    // Print the contents of deviceInfoList
    for (const auto& device : Device::devices) {
        device.printDeviceInfo();
        cout << endl; // Add a newline for better readability
    }
    Job::populateFromXMLReader(xmlReader);
    cout << "Job List:"<< endl;
    // Populate jobs from XMLReader.
    for (const auto& job : Job::jobs) {
        // Call the print function.
        job.printJobInfo();
        // Add a newline for better readability.
        cout << endl;
    }
    return 0;
}

########################################################################################################
###################################THIS IS A WORKING CODE ##############################################
########################################################################################################

XMLReader.h

#ifndef XMLREADER_H
#define XMLREADER_H

#include <vector>
#include <string> // Include <string> to use std::string
#include "tinyxml.h"
#include "../Job.h" // Include the header file for your Job class
#include "../Device.h" // Include the header file for your Device class


// Forward declaration of TiXmlElement to avoid including TinyXML headers in the header file
class TiXmlElement;

// Declare the DeviceInfo struct
struct DeviceInfo {
    std::string deviceName;
    int emissions;
    int speed;
};
struct JobInfo {
    int jobNumber;
    int pageCount;
    std:: string userName;
};
class XMLReader {
private:
    TiXmlDocument doc;
    std::vector<DeviceInfo> deviceInfoList;
    std::vector<JobInfo> jobInfoList;

public:
    XMLReader(); // Constructor
    bool readerXML();
    const std::vector<DeviceInfo>& getDeviceInfoList() const { return deviceInfoList; }
    const std::vector<JobInfo>& getJobInfoList() const { return jobInfoList; }
};
#endif // XMLREADER_H

########################################################################################################
###################################THIS IS A WORKING CODE ##############################################
########################################################################################################

XMLReader.cpp

#include "XMLReader.h"
#include "tinyxml.h"
#include <iostream>
#include <string>
#include <vector> // For storing job information
#include "../Job.h"
#include "../Device.h"

using namespace std;

XMLReader::XMLReader() {
    // Constructor implementation
}
bool XMLReader::readerXML() {
    TiXmlDocument doc;
    if (!doc.LoadFile("C:\\Users\\Boss\\Desktop\\A.J._23-24\\PSE\\testFolder\\XMLREADER\\data.xml")) {
        cerr << "Failed to load file: " << doc.ErrorDesc() << endl;
        return false;
    }
    TiXmlElement* root = doc.FirstChildElement("SYSTEM");
    if (!root) {
        cerr << "Failed to find root element SYSTEM." << endl;
        return false;
    }
// Loop through DEVICE elements
    for (TiXmlElement* deviceElement = root->FirstChildElement("DEVICE"); deviceElement; deviceElement = deviceElement->NextSiblingElement("DEVICE")) {
        DeviceInfo deviceInfo;
        // Get name element from DEVICE
        TiXmlElement* nameElement = deviceElement->FirstChildElement("name");
        if (!nameElement) {
            cerr << "Failed to find NAME element for a device. Continuing onto the next attribute." << endl;
            continue;
        }
        // Get emissions element from DEVICE
        TiXmlElement* emissionsElement = deviceElement->FirstChildElement("emissions");
        if (!emissionsElement) {
            cerr << "Failed to find EMISSIONS element for device. Continuing onto the next attribute." << endl;
            continue;
        }
        // Get speed element from DEVICE
        TiXmlElement* speedElement = deviceElement->FirstChildElement("speed");
        if (!speedElement) {
            cerr << "Failed to find SPEED element for device. Continuing onto the next attribute." << endl;
            continue;
        }
        // Extract and convert values to integers
        deviceInfo.deviceName = nameElement->GetText();
        deviceInfo.emissions = atoi(emissionsElement->GetText());
        deviceInfo.speed = atoi(speedElement->GetText());

        // Error handling and validation
        if (deviceInfo.deviceName.empty()) {
            cerr << "Device name is empty for a device." << endl;
            continue;
        }
        if (deviceInfo.emissions <= 0) {
            cerr << "Invalid emissions value for device: " << deviceInfo.emissions << endl;
            continue;
        }
        if (deviceInfo.speed <= 0) {
            cerr << "Invalid speed value for device: " << deviceInfo.speed << endl;
            continue;
        }
        deviceInfoList.push_back(deviceInfo);
    }
    for (TiXmlElement* jobElement = root->FirstChildElement("JOB"); jobElement; jobElement = jobElement->NextSiblingElement("JOB")) {
        JobInfo jobInfo; // Create a new Job object for each JOB element

        TiXmlElement* jobNumberElement = jobElement->FirstChildElement("jobNumber");
        if (!jobNumberElement) {
            cerr << "Failed to find jobNumber element for a job. Continuing onto the next attribute." << endl;
            continue;
        }
        TiXmlElement* pageCountElement = jobElement->FirstChildElement("pageCount");
        if (!pageCountElement) {
            cerr << "Failed to find pageCount element for a job. Continuing onto the next attribute." << endl;
            continue;
        }
        TiXmlElement* userNameElement = jobElement->FirstChildElement("userName");
        if (!userNameElement) {
            cerr << "Failed to find userName element for a job. Continuing onto the next attribute." << endl;
            continue;
        }

        jobInfo.jobNumber = atoi(jobNumberElement->GetText());
        jobInfo.pageCount = atoi(pageCountElement->GetText());
        jobInfo.userName = userNameElement->GetText();

        jobInfoList.push_back(jobInfo);
    }
    doc.Clear();
    return true; // Return true indicating successful XML reading
}

########################################################################################################
###################################THIS IS A WORKING CODE ##############################################
########################################################################################################

Device.cpp

#include <iostream>
#include "Device.h"
#include "XMLREADER/XMLReader.h"

using namespace std;
vector<Device> Device::devices;
Device::Device(const std::string &name, int emissions, int speed)
        : deviceName(name), emissions(emissions), speed(speed) {}

// Static member function to populate jobs from XMLReader
void Device::populateFromXMLReader(const XMLReader& xmlReader) {
    // Access vectors from XMLReader
    const vector<DeviceInfo>& deviceInfoList = xmlReader.getDeviceInfoList();

    // Print the size of jobInfoList to verify if it's populated correctly
    cout << "Number of Device info entries: " << deviceInfoList.size() << endl;
    // Clear any existing jobs before populating new ones
    // Assuming jobs is a static vector declared somewhere outside the class
    devices.clear();
    // Populate Device objects using data from deviceInfoList vector
    for (const auto& deviceInfo : deviceInfoList) {
        Device device(deviceInfo.deviceName, deviceInfo.emissions, deviceInfo.speed);
        // Do something with the job object, such as adding it to another vector
        // For example, you can add it to a vector of Job objects defined outside the class
        devices.push_back(device);
    }
}
// This is a function use to print each one of the contents in the list of Devices.
void Device::printDeviceInfo() const {
    cout << "Device Name: " << deviceName << endl;
    cout << "Emissions: " << emissions << endl;
    cout << "Speed: " << speed << endl;
}

########################################################################################################
###################################THIS IS A WORKING CODE ##############################################
########################################################################################################

Device.h

#ifndef TESTFOLDER_DEVICE_H
#define TESTFOLDER_DEVICE_H
#include <iostream>
#include "XMLREADER/XMLReader.h"
#include <string>
#include <vector>

class Device {
private:
    std::string deviceName;
    int emissions;
    int speed;

public:
    // Constructor
    Device(const std::string& name = "", int emissions = 0, int speed = 0);

    // Function to populate jobs from XMLReader
    static void populateFromXMLReader(const XMLReader& xmlReader);
    void printDeviceInfo() const;

    static std::vector<Device> devices;
};

#endif //TESTFOLDER_DEVICE_H

########################################################################################################
###################################THIS IS A WORKING CODE ##############################################
########################################################################################################

Job.cpp

#include <iostream>
#include "Job.h"
#include "XMLREADER/XMLReader.h"

using namespace std;
vector<Job> Job::jobs;
Job::Job(int number, int count, const string& name)
        : jobNumber(number), pageCount(count), userName(name) {}

// Static member function to populate jobs from XMLReader
void Job::populateFromXMLReader(const XMLReader& xmlReader) {
    // Access vectors from XMLReader
    const vector<JobInfo>& jobInfoList = xmlReader.getJobInfoList();
    // Print the size of jobInfoList to verify if it's populated correctly
    cout << "Number of job info entries: " << jobInfoList.size() << endl;
    // Clear any existing jobs before populating new ones
    jobs.clear();
    // Populate Job objects using data from jobInfoList vector
    for (const auto& jobInfo : jobInfoList) {
        Job job(jobInfo.jobNumber, jobInfo.pageCount, jobInfo.userName);
        jobs.push_back(job);
    }
}
// This is a function use to print each one of the contents in the list of Jobs.
void Job::printJobInfo() const {
    cout << "Job Number: " << jobNumber << endl;
    cout << "Page Count: " << pageCount << endl;
    cout << "User Name: " << userName << endl;
}

########################################################################################################
###################################THIS IS A WORKING CODE ##############################################
########################################################################################################

Job.h

#ifndef TESTFOLDER_JOB_H
#define TESTFOLDER_JOB_H
#include <iostream>
#include "XMLREADER/XMLReader.h"
#include <string>
#include <vector>

class Job {
private:
    int jobNumber;
    int pageCount;
    std::string userName;

public:
    // Constructor
    Job(int number = 0, int count = 0, const std::string& name = "");

    // Function to populate jobs from XMLReader
    static void populateFromXMLReader(const XMLReader& xmlReader);
    void printJobInfo() const;

    static std::vector<Job> jobs;
};

#endif //TESTFOLDER_JOB_H

########################################################################################################
###################################THIS IS A WORKING CODE ##############################################
########################################################################################################




########################################################################################################
###################################THIS IS A WORKING CODE ##############################################
########################################################################################################
